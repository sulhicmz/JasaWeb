name: Issue Validation

on:
  issues:
    types: [opened, edited]

jobs:
  validate-issue:
    runs-on: ubuntu-latest
    if: github.event.action == 'opened'
    permissions:
      issues: write
      contents: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: |
          cd .github/scripts
          npm init -y
          npm install

      - name: Validate issue completeness
        uses: actions/github-script@v7
        with:
          script: |
            const { IssueValidator } = require('./.github/scripts/validate-issue.js');
            
            const validator = new IssueValidator();
            const issue = context.payload.issue;
            
            // Determine issue type from title and labels
            let issueType = 'bug'; // default
            if (issue.title.includes('[FEATURE]')) issueType = 'feature';
            else if (issue.title.includes('[SECURITY]')) issueType = 'security';
            else if (issue.title.includes('[BUILD]')) issueType = 'build';
            else if (issue.title.includes('[CONFIG]')) issueType = 'config';
            else if (issue.title.includes('[TASK]')) issueType = 'task';
            
            const issueData = {
              title: issue.title,
              body: issue.body || '',
              labels: issue.labels.map(l => l.name),
              type: issueType
            };
            
            const validation = validator.validateIssue(issueData);
            const searchTerms = validator.generateSearchTerms(issueData);
            
            // Create validation comment
            let comment = '## ðŸ” Issue Validation\n\n';
            
            if (validation.isValid) {
              comment += 'âœ… **Issue looks complete!**\n\n';
            } else {
              comment += 'âš ï¸ **Issue needs attention**\n\n';
            }
            
            if (validation.warnings.length > 0) {
              comment += '### ðŸš¨ Warnings\n';
              validation.warnings.forEach(warning => {
                comment += `- ${warning}\n`;
              });
              comment += '\n';
            }
            
            if (validation.suggestions.length > 0) {
              comment += '### ðŸ’¡ Suggestions\n';
              validation.suggestions.forEach(suggestion => {
                comment += `- ${suggestion}\n`;
              });
              comment += '\n';
            }
            
            // Duplicate risk assessment
            comment += `### ðŸŽ¯ Duplicate Risk: ${validation.duplicateRisk.toUpperCase()}\n\n`;
            
            if (validation.duplicateRisk === 'high') {
              comment += 'âš ï¸ **High duplicate risk detected!** Please search thoroughly for similar issues before proceeding.\n\n';
            } else if (validation.duplicateRisk === 'medium') {
              comment += 'âš¡ **Medium duplicate risk** - double-check for similar issues.\n\n';
            }
            
            // Search suggestions
            if (searchTerms.length > 0) {
              comment += '### ðŸ” Suggested Search Terms\n';
              searchTerms.forEach(term => {
                comment += `- \`${term}\`\n`;
              });
              comment += '\n';
            }
            
            // Add helpful links
            comment += '### ðŸ“š Helpful Resources\n';
            comment += '- [Issue Templates Guide](https://github.com/sulhicmz/JasaWeb/blob/main/.github/ISSUE_TEMPLATE/GUIDE.md)\n';
            comment += '- [Troubleshooting Guide](https://github.com/sulhicmz/JasaWeb/blob/main/docs/EMERGENCY_RESOLUTION_PLAN.md)\n';
            comment += '- [Documentation](https://github.com/sulabicmz/JasaWeb/blob/main/README.md)\n\n';
            
            comment += '---\n';
            comment += '*This comment was generated automatically by the issue validation bot.*';
            
            // Post comment
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              body: comment
            });
            
            // Add labels based on validation
            const labelsToAdd = [];
            
            if (validation.duplicateRisk === 'high') {
              labelsToAdd.push('high-duplicate-risk');
            } else if (validation.duplicateRisk === 'medium') {
              labelsToAdd.push('medium-duplicate-risk');
            }
            
            if (!validation.isValid) {
              labelsToAdd.push('needs-information');
            }
            
            if (labelsToAdd.length > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                labels: labelsToAdd
              });
            }

  check-duplicates:
    runs-on: ubuntu-latest
    if: github.event.action == 'opened'
    permissions:
      issues: read
    
    steps:
      - name: Check for potential duplicates
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const title = issue.title.toLowerCase();
            const body = (issue.body || '').toLowerCase();
            
            // Extract keywords from the issue
            const keywords = [];
            
            // Common error patterns
            const errorPatterns = [
              /error:?\s*([^\n]+)/gi,
              /cannot find module ([^\n]+)/gi,
              /typeerror:?\s*([^\n]+)/gi,
              /referenceerror:?\s*([^\n]+)/gi
            ];
            
            errorPatterns.forEach(pattern => {
              const matches = body.match(pattern);
              if (matches) {
                keywords.push(...matches.map(m => m.trim()));
              }
            });
            
            // Component names
            const components = ['astro', 'nestjs', 'api', 'database', 'auth', 'docker'];
            components.forEach(comp => {
              if (title.includes(comp) || body.includes(comp)) {
                keywords.push(comp);
              }
            });
            
            // Search for similar issues
            if (keywords.length > 0) {
              const query = keywords.slice(0, 3).join(' ');
              console.log(`Searching for issues with query: ${query}`);
              
              try {
                const searchResults = await github.rest.search.issuesAndPullRequests({
                  q: `${query} repo:${context.repo.owner}/${context.repo.repo} state:open`,
                  per_page: 5
                });
                
                const similarIssues = searchResults.data.items.filter(item => 
                  item.number !== issue.number && 
                  !item.pull_request
                );
                
                if (similarIssues.length > 0) {
                  console.log(`Found ${similarIssues.length} potentially similar issues`);
                  
                  // Create comment with similar issues
                  let comment = '## ðŸ” Potential Duplicates Found\n\n';
                  comment += 'The following issues might be related:\n\n';
                  
                  similarIssues.forEach(similarIssue => {
                    comment += `- **#${similarIssue.number}: ${similarIssue.title}**\n`;
                    comment += `  - State: ${similarIssue.state}\n`;
                    comment += `  - Labels: ${similarIssue.labels.map(l => l.name).join(', ')}\n`;
                    comment += `  - Created: ${new Date(similarIssue.created_at).toLocaleDateString()}\n\n`;
                  });
                  
                  comment += 'Please review these issues to avoid duplicates.\n\n';
                  comment += '---\n';
                  comment += '*This comment was generated automatically by the duplicate detection bot.*';
                  
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    body: comment
                  });
                }
              } catch (error) {
                console.log('Error searching for duplicates:', error.message);
              }
            }