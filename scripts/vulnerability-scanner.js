#!/usr/bin/env node

/**
 * Enhanced Vulnerability Scanner
 * Real-time vulnerability detection with automated remediation suggestions
 */

const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

console.log('üîç Enhanced Vulnerability Scanner\n');

class VulnerabilityScanner {
  constructor() {
    this.vulnerabilities = [];
    this.recommendations = [];
    this.criticalPackages = [
      'js-yaml', 'nodemailer', 'validator', 'jws', 'esbuild', 
      'body-parser', 'form-data', 'tough-cookie', 'braces', 
      'micromatch', 'glob', 'semver', 'word-wrap', 'axios', 
      'follow-redirects', 'cross-spawn', 'path-to-regexp', 'undici', 'ws'
    ];
  }

  async scanVulnerabilities() {
    console.log('üö® Scanning for known vulnerabilities...');
    
    try {
      // Check if pnpm is available
      const pnpmVersion = execSync('pnpm --version', { encoding: 'utf-8', stdio: 'pipe' }).trim();
      console.log(`Using pnpm version: ${pnpmVersion}\n`);

      // Get comprehensive audit results
      const auditOutput = execSync('pnpm audit --json', { 
        encoding: 'utf-8', 
        stdio: 'pipe' 
      });
      
      const auditData = JSON.parse(auditOutput);
      this.analyzeVulnerabilities(auditData);
      
    } catch (error) {
      console.error('‚ùå Audit failed:', error.message);
      
      // Fallback to npm if pnpm audit fails
      try {
        console.log('üîÑ Falling back to npm audit...');
        const npmAuditOutput = execSync('npm audit --json', { 
          encoding: 'utf-8', 
          stdio: 'pipe' 
        });
        const npmAuditData = JSON.parse(npmAuditOutput);
        this.analyzeVulnerabilities(npmAuditData);
      } catch (npmError) {
        console.error('‚ùå Both pnpm and npm audits failed');
        process.exit(1);
      }
    }
  }

  analyzeVulnerabilities(auditData) {
    if (!auditData.vulnerabilities) {
      console.log('‚úÖ No vulnerabilities found');
      return;
    }

    const vulnerabilities = auditData.vulnerabilities;
    
    for (const [packageName, vulnData] of Object.entries(vulnerabilities)) {
      const severity = vulnData.severity || 'unknown';
      const title = vulnData.title || 'Unknown vulnerability';
      
      this.vulnerabilities.push({
        package: packageName,
        severity,
        title,
        url: vulnData.url,
        fixAvailable: vulnData.fixAvailable,
        patchedVersions: vulnData.patched_versions,
        recommendation: this.generateRecommendation(packageName, vulnData)
      });

      // Critical package handling
      if (this.criticalPackages.includes(packageName)) {
        console.log(`üö® CRITICAL: ${packageName} - ${title}`);
        console.log(`   Severity: ${severity.toUpperCase()}`);
        console.log(`   Fix Available: ${vulnData.fixAvailable}`);
        console.log(`   Patched in: ${vulnData.patched_versions || 'N/A'}`);
        console.log(`   Details: ${vulnData.url || 'No URL provided'}\n`);
      }
    }

    this.generateSummary();
    this.generateRemediationPlan();
  }

  generateRecommendation(packageName, vulnData) {
    if (vulnData.fixAvailable && vulnData.fixAvailable.version) {
      return `Upgrade ${packageName} to ${vulnData.fixAvailable.version}`;
    } else {
      return `Monitor ${packageName} for security updates. Consider alternative packages.`;
    }
  }

  generateSummary() {
    const severityCount = {
      critical: 0,
      high: 0,
      moderate: 0,
      low: 0,
      unknown: 0
    };

    this.vulnerabilities.forEach(vuln => {
      severityCount[vuln.severity] = (severityCount[vuln.severity] || 0) + 1;
    });

    console.log('üìä Vulnerability Summary:');
    console.log('='.repeat(40));
    Object.entries(severityCount).forEach(([severity, count]) => {
      if (count > 0) {
        const icon = severity === 'critical' ? 'üö®' : severity === 'high' ? '‚ö†Ô∏è' : '‚ÑπÔ∏è';
        console.log(`${icon} ${severity.toUpperCase()}: ${count}`);
      }
    });
    console.log('='.repeat(40) + '\n');
  }

  generateRemediationPlan() {
    console.log('üõ†Ô∏è  Automated Remediation Plan:\n');
    
    const criticalVulns = this.vulnerabilities.filter(v => v.severity === 'critical');
    const highVulns = this.vulnerabilities.filter(v => v.severity === 'high');
    
    if (criticalVulns.length > 0) {
      console.log('üö® CRITICAL - Immediate Action Required:');
      criticalVulns.forEach(vuln => {
        console.log(`  ‚ùå ${vuln.package}: ${vuln.recommendation}`);
      });
      console.log();
    }

    if (highVulns.length > 0) {
      console.log('‚ö†Ô∏è  HIGH - Prioritize Fixes:');
      highVulns.forEach(vuln => {
        console.log(`  ‚ö†Ô∏è  ${vuln.package}: ${vuln.recommendation}`);
      });
      console.log();
    }

    this.generatePackageOverrides();
  }

  generatePackageOverrides() {
    console.log('üìù Suggested pnpm overrides for package.json:');
    console.log('```json');
    console.log('"pnpm": {');
    console.log('  "overrides": {');
    
    const overrides = {};
    this.vulnerabilities.forEach(vuln => {
      if (vuln.fixAvailable && vuln.fixAvailable.version) {
        overrides[vuln.package] = vuln.fixAvailable.version;
      }
    });

    Object.entries(overrides).forEach(([pkg, version], index) => {
      const isLast = index === Object.keys(overrides).length - 1;
      console.log(`    "${pkg}": "${version}"${isLast ? '' : ','}`);
    });
    
    console.log('  }');
    console.log('}');
    console.log('```\n');
  }

  async applyAutoFixes() {
    console.log('üîß Attempting automatic fixes...');
    
    try {
      // Try to automatically fix vulnerabilities
      console.log('Running pnpm audit --fix...');
      execSync('pnpm audit --fix', { stdio: 'inherit' });
      console.log('‚úÖ Automatic fixes applied');
    } catch (error) {
      console.log('‚ö†Ô∏è  Some vulnerabilities could not be fixed automatically');
      console.log('Manual intervention may be required\n');
    }
  }

  exportReport() {
    const report = {
      scanDate: new Date().toISOString(),
      totalVulnerabilities: this.vulnerabilities.length,
      severityBreakdown: this.vulnerabilities.reduce((acc, v) => {
        acc[v.severity] = (acc[v.severity] || 0) + 1;
        return acc;
      }, {}),
      vulnerabilities: this.vulnerabilities,
      recommendations: this.recommendations
    };

    try {
      fs.writeFileSync('vulnerability-report.json', JSON.stringify(report, null, 2));
      console.log('üìÑ Detailed report saved to vulnerability-report.json');
    } catch (error) {
      console.error('‚ùå Failed to save report:', error.message);
    }
  }
}

// Main execution
async function main() {
  const scanner = new VulnerabilityScanner();
  
  try {
    await scanner.scanVulnerabilities();
    
    // Ask user if they want to apply auto-fixes
    const args = process.argv.slice(2);
    if (args.includes('--fix')) {
      await scanner.applyAutoFixes();
    }
    
    scanner.exportReport();
    
    // Exit with error code if critical vulnerabilities found
    const criticalCount = scanner.vulnerabilities.filter(v => v.severity === 'critical').length;
    if (criticalCount > 0) {
      console.log(`‚ùå Scan completed with ${criticalCount} critical vulnerabilities`);
      process.exit(1);
    } else {
      console.log('‚úÖ Vulnerability scan completed successfully');
      process.exit(0);
    }
    
  } catch (error) {
    console.error('‚ùå Vulnerability scan failed:', error.message);
    process.exit(1);
  }
}

if (require.main === module) {
  main();
}

module.exports = VulnerabilityScanner;