---
// DashboardCharts.astro - Enhanced Analytics charts with Chart.js
---

<div class="glass-panel p-6 rounded-xl">
  <div class="flex items-center justify-between mb-6">
    <h2 class="text-xl font-bold text-white">Analytics Overview</h2>
    <div class="flex items-center space-x-2">
      <button id="chartRefreshBtn" class="px-3 py-1 bg-slate-700 hover:bg-slate-600 text-white rounded-lg text-sm transition-colors duration-200">
        <i class="fas fa-sync-alt mr-1"></i> Refresh
      </button>
      <select id="chartTimeRange" class="px-3 py-1 bg-slate-700 text-white rounded-lg text-sm border border-slate-600 focus:border-blue-500 focus:outline-none">
        <option value="7">Last 7 days</option>
        <option value="30" selected>Last 30 days</option>
        <option value="90">Last 90 days</option>
      </select>
    </div>
  </div>
  
  <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
    <!-- Project Status Chart -->
    <div class="bg-slate-800/50 p-4 rounded-lg">
      <h3 class="text-white font-medium mb-4">Project Status Distribution</h3>
      <div class="relative" style="height: 250px;">
        <canvas id="projectStatusChart"></canvas>
      </div>
      <div id="projectStatusLegend" class="mt-3 flex flex-wrap gap-2 justify-center"></div>
    </div>
    
    <!-- Ticket Priority Chart -->
    <div class="bg-slate-800/50 p-4 rounded-lg">
      <h3 class="text-white font-medium mb-4">Ticket Priority Breakdown</h3>
      <div class="relative" style="height: 250px;">
        <canvas id="ticketPriorityChart"></canvas>
      </div>
      <div id="ticketPriorityLegend" class="mt-3 flex flex-wrap gap-2 justify-center"></div>
    </div>
  </div>
  
  <!-- Revenue Trend Chart -->
  <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
    <div class="bg-slate-800/50 p-4 rounded-lg">
      <h3 class="text-white font-medium mb-4">Revenue Trend</h3>
      <div class="relative" style="height: 250px;">
        <canvas id="revenueTrendChart"></canvas>
      </div>
    </div>
    
    <!-- Project Completion Rate -->
    <div class="bg-slate-800/50 p-4 rounded-lg">
      <h3 class="text-white font-medium mb-4">Project Completion Rate</h3>
      <div class="relative" style="height: 250px;">
        <canvas id="completionRateChart"></canvas>
      </div>
    </div>
  </div>
  
  <!-- Milestone Timeline -->
  <div class="bg-slate-800/50 p-4 rounded-lg">
    <h3 class="text-white font-medium mb-4">Weekly Milestone Progress</h3>
    <div class="relative" style="height: 300px;">
      <canvas id="milestoneTimelineChart"></canvas>
    </div>
  </div>

  <!-- KPI Metrics Overview -->
  <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mt-6">
    <!-- Project Health Score -->
    <div class="bg-gradient-to-br from-blue-600/20 to-blue-800/20 p-4 rounded-lg border border-blue-500/30">
      <div class="flex items-center justify-between mb-2">
        <h4 class="text-blue-300 font-medium text-sm">Project Health</h4>
        <i class="fas fa-heartbeat text-blue-400"></i>
      </div>
      <div class="text-2xl font-bold text-white mb-1" id="projectHealthScore">--</div>
      <div class="text-xs text-gray-400">Overall Score</div>
      <div class="mt-2 w-full bg-slate-700 rounded-full h-1.5">
        <div id="projectHealthBar" class="bg-blue-500 h-1.5 rounded-full transition-all duration-500" style="width: 0%"></div>
      </div>
    </div>

    <!-- Team Productivity -->
    <div class="bg-gradient-to-br from-green-600/20 to-green-800/20 p-4 rounded-lg border border-green-500/30">
      <div class="flex items-center justify-between mb-2">
        <h4 class="text-green-300 font-medium text-sm">Productivity</h4>
        <i class="fas fa-rocket text-green-400"></i>
      </div>
      <div class="text-2xl font-bold text-white mb-1" id="productivityScore">--</div>
      <div class="text-xs text-gray-400">Tasks/Week</div>
      <div class="mt-2 w-full bg-slate-700 rounded-full h-1.5">
        <div id="productivityBar" class="bg-green-500 h-1.5 rounded-full transition-all duration-500" style="width: 0%"></div>
      </div>
    </div>

    <!-- Client Satisfaction -->
    <div class="bg-gradient-to-br from-purple-600/20 to-purple-800/20 p-4 rounded-lg border border-purple-500/30">
      <div class="flex items-center justify-between mb-2">
        <h4 class="text-purple-300 font-medium text-sm">Satisfaction</h4>
        <i class="fas fa-smile text-purple-400"></i>
      </div>
      <div class="text-2xl font-bold text-white mb-1" id="satisfactionScore">--</div>
      <div class="text-xs text-gray-400">Client Rating</div>
      <div class="mt-2 w-full bg-slate-700 rounded-full h-1.5">
        <div id="satisfactionBar" class="bg-purple-500 h-1.5 rounded-full transition-all duration-500" style="width: 0%"></div>
      </div>
    </div>

    <!-- Budget Efficiency -->
    <div class="bg-gradient-to-br from-yellow-600/20 to-yellow-800/20 p-4 rounded-lg border border-yellow-500/30">
      <div class="flex items-center justify-between mb-2">
        <h4 class="text-yellow-300 font-medium text-sm">Budget Efficiency</h4>
        <i class="fas fa-dollar-sign text-yellow-400"></i>
      </div>
      <div class="text-2xl font-bold text-white mb-1" id="budgetEfficiency">--</div>
      <div class="text-xs text-gray-400">On Budget</div>
      <div class="mt-2 w-full bg-slate-700 rounded-full h-1.5">
        <div id="budgetBar" class="bg-yellow-500 h-1.5 rounded-full transition-all duration-500" style="width: 0%"></div>
      </div>
    </div>
  </div>
</div>

<!-- Chart.js CDN -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

<script>
  class DashboardCharts {
    constructor() {
      this.charts = {};
      this.currentTimeRange = 30;
      this.kpiData = {};
      this.init();
    }

    init() {
      this.initCharts();
      this.setupEventListeners();
      this.loadKPIData();
      
      // Listen for data updates
      window.addEventListener('stats-updated', (e) => {
        this.updateCharts(e.detail.stats);
        this.updateKPIs(e.detail.stats);
      });

      // Listen for real-time updates
      window.addEventListener('dashboard-update', (e) => {
        this.handleRealtimeUpdate(e.detail);
      });

      // Listen for analytics updates
      window.addEventListener('analytics-updated', (e) => {
        this.updateAdvancedKPIs(e.detail);
      });
    }

    setupEventListeners() {
      // Refresh button
      document.getElementById('chartRefreshBtn')?.addEventListener('click', () => {
        this.refreshAllCharts();
      });

      // Time range selector
      document.getElementById('chartTimeRange')?.addEventListener('change', (e) => {
        this.currentTimeRange = parseInt(e.target.value);
        this.refreshAllCharts();
      });
    }

    initCharts() {
      this.initProjectStatusChart();
      this.initTicketPriorityChart();
      this.initRevenueTrendChart();
      this.initCompletionRateChart();
      this.initMilestoneTimelineChart();
    }

    initProjectStatusChart() {
      const ctx = document.getElementById('projectStatusChart')?.getContext('2d');
      if (!ctx) return;

      this.charts.projectStatus = new Chart(ctx, {
        type: 'doughnut',
        data: {
          labels: ['Active', 'Completed', 'On Hold', 'Planning'],
          datasets: [{
            data: [3, 5, 1, 2],
            backgroundColor: [
              '#10b981',
              '#3b82f6', 
              '#f59e0b',
              '#6b7280'
            ],
            borderWidth: 0,
            hoverOffset: 4
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              backgroundColor: 'rgba(0, 0, 0, 0.8)',
              titleColor: '#fff',
              bodyColor: '#fff',
              borderColor: '#333',
              borderWidth: 1,
              callbacks: {
                label: function(context) {
                  const total = context.dataset.data.reduce((a, b) => a + b, 0);
                  const percentage = ((context.parsed / total) * 100).toFixed(1);
                  return `${context.label}: ${context.parsed} (${percentage}%)`;
                }
              }
            }
          },
          cutout: '60%'
        }
      });

      this.createCustomLegend('projectStatusChart', ['Active', 'Completed', 'On Hold', 'Planning'], ['#10b981', '#3b82f6', '#f59e0b', '#6b7280']);
    }

    initTicketPriorityChart() {
      const ctx = document.getElementById('ticketPriorityChart')?.getContext('2d');
      if (!ctx) return;

      this.charts.ticketPriority = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: ['Low', 'Medium', 'High', 'Critical'],
          datasets: [{
            label: 'Tickets',
            data: [2, 5, 3, 1],
            backgroundColor: [
              '#6b7280',
              '#f59e0b',
              '#f97316',
              '#ef4444'
            ],
            borderRadius: 6,
            borderSkipped: false,
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              backgroundColor: 'rgba(0, 0, 0, 0.8)',
              titleColor: '#fff',
              bodyColor: '#fff'
            }
          },
          scales: {
            y: {
              beginAtZero: true,
              grid: {
                color: 'rgba(255, 255, 255, 0.1)',
                drawBorder: false
              },
              ticks: {
                color: '#9ca3af',
                stepSize: 1
              }
            },
            x: {
              grid: {
                display: false,
                drawBorder: false
              },
              ticks: {
                color: '#9ca3af'
              }
            }
          }
        }
      });

      this.createCustomLegend('ticketPriorityChart', ['Low', 'Medium', 'High', 'Critical'], ['#6b7280', '#f59e0b', '#f97316', '#ef4444']);
    }

    initRevenueTrendChart() {
      const ctx = document.getElementById('revenueTrendChart')?.getContext('2d');
      if (!ctx) return;

      // Generate sample data for the selected time range
      const labels = this.generateTimeLabels();
      const revenueData = this.generateRevenueData(labels.length);

      this.charts.revenueTrend = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'Revenue',
            data: revenueData,
            borderColor: '#10b981',
            backgroundColor: 'rgba(16, 185, 129, 0.1)',
            borderWidth: 2,
            fill: true,
            tension: 0.4,
            pointBackgroundColor: '#10b981',
            pointBorderColor: '#fff',
            pointBorderWidth: 2,
            pointRadius: 4,
            pointHoverRadius: 6
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              backgroundColor: 'rgba(0, 0, 0, 0.8)',
              titleColor: '#fff',
              bodyColor: '#fff',
              callbacks: {
                label: function(context) {
                  return `Revenue: $${context.parsed.y.toLocaleString()}`;
                }
              }
            }
          },
          scales: {
            y: {
              beginAtZero: true,
              grid: {
                color: 'rgba(255, 255, 255, 0.1)',
                drawBorder: false
              },
              ticks: {
                color: '#9ca3af',
                callback: function(value) {
                  return '$' + value.toLocaleString();
                }
              }
            },
            x: {
              grid: {
                display: false,
                drawBorder: false
              },
              ticks: {
                color: '#9ca3af'
              }
            }
          }
        }
      });
    }

    initCompletionRateChart() {
      const ctx = document.getElementById('completionRateChart')?.getContext('2d');
      if (!ctx) return;

      const labels = this.generateTimeLabels();
      const completionData = labels.map(() => Math.floor(Math.random() * 30) + 70);

      this.charts.completionRate = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'Completion Rate',
            data: completionData,
            borderColor: '#3b82f6',
            backgroundColor: 'rgba(59, 130, 246, 0.1)',
            borderWidth: 2,
            fill: true,
            tension: 0.4,
            pointBackgroundColor: '#3b82f6',
            pointBorderColor: '#fff',
            pointBorderWidth: 2,
            pointRadius: 4,
            pointHoverRadius: 6
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              backgroundColor: 'rgba(0, 0, 0, 0.8)',
              titleColor: '#fff',
              bodyColor: '#fff',
              callbacks: {
                label: function(context) {
                  return `Completion: ${context.parsed.y}%`;
                }
              }
            }
          },
          scales: {
            y: {
              beginAtZero: false,
              min: 0,
              max: 100,
              grid: {
                color: 'rgba(255, 255, 255, 0.1)',
                drawBorder: false
              },
              ticks: {
                color: '#9ca3af',
                callback: function(value) {
                  return value + '%';
                }
              }
            },
            x: {
              grid: {
                display: false,
                drawBorder: false
              },
              ticks: {
                color: '#9ca3af'
              }
            }
          }
        }
      });
    }

    initMilestoneTimelineChart() {
      const ctx = document.getElementById('milestoneTimelineChart')?.getContext('2d');
      if (!ctx) return;

      this.charts.milestoneTimeline = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: ['Week 1', 'Week 2', 'Week 3', 'Week 4'],
          datasets: [
            {
              label: 'Completed',
              data: [2, 3, 5, 4],
              backgroundColor: '#10b981',
              borderRadius: 4,
              borderSkipped: false,
            },
            {
              label: 'Planned',
              data: [3, 4, 6, 5],
              backgroundColor: '#3b82f6',
              borderRadius: 4,
              borderSkipped: false,
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: true,
              position: 'top',
              labels: {
                color: '#9ca3af',
                usePointStyle: true,
                padding: 20
              }
            },
            tooltip: {
              backgroundColor: 'rgba(0, 0, 0, 0.8)',
              titleColor: '#fff',
              bodyColor: '#fff'
            }
          },
          scales: {
            y: {
              beginAtZero: true,
              grid: {
                color: 'rgba(255, 255, 255, 0.1)',
                drawBorder: false
              },
              ticks: {
                color: '#9ca3af',
                stepSize: 1
              }
            },
            x: {
              grid: {
                display: false,
                drawBorder: false
              },
              ticks: {
                color: '#9ca3af'
              }
            }
          }
        }
      });
    }

    createCustomLegend(chartId, labels, colors) {
      const legendContainer = document.getElementById(`${chartId}Legend`);
      if (!legendContainer) return;

      legendContainer.innerHTML = labels.map((label, index) => `
        <div class="flex items-center space-x-2">
          <div class="w-3 h-3 rounded-full" style="background-color: ${colors[index]}"></div>
          <span class="text-xs text-gray-400">${label}</span>
        </div>
      `).join('');
    }

    generateTimeLabels() {
      const labels = [];
      const now = new Date();
      
      if (this.currentTimeRange === 7) {
        // Last 7 days
        for (let i = 6; i >= 0; i--) {
          const date = new Date(now);
          date.setDate(date.getDate() - i);
          labels.push(date.toLocaleDateString('en-US', { weekday: 'short' }));
        }
      } else if (this.currentTimeRange === 30) {
        // Last 30 days (weekly)
        for (let i = 4; i >= 0; i--) {
          const date = new Date(now);
          date.setDate(date.getDate() - (i * 7));
          labels.push(`Week ${5 - i}`);
        }
      } else {
        // Last 90 days (monthly)
        for (let i = 3; i >= 0; i--) {
          const date = new Date(now);
          date.setMonth(date.getMonth() - i);
          labels.push(date.toLocaleDateString('en-US', { month: 'short' }));
        }
      }
      
      return labels;
    }

    generateRevenueData(length) {
      // Generate realistic revenue data
      const baseRevenue = 50000;
      return Array.from({ length }, () => 
        baseRevenue + Math.floor(Math.random() * 30000) - 10000
      );
    }

    updateCharts(stats) {
      if (stats.projects && this.charts.projectStatus) {
        const planningCount = stats.projects.total - stats.projects.active - stats.projects.completed - stats.projects.onHold;
        this.charts.projectStatus.data.datasets[0].data = [
          stats.projects.active,
          stats.projects.completed,
          stats.projects.onHold,
          Math.max(0, planningCount)
        ];
        this.charts.projectStatus.update('none');
      }

      if (stats.tickets && this.charts.ticketPriority) {
        // Estimate priority distribution
        const total = stats.tickets.total;
        const critical = stats.tickets.critical;
        const high = Math.max(0, stats.tickets.highPriority - critical);
        const medium = Math.floor(total * 0.4);
        const low = Math.max(0, total - critical - high - medium);

        this.charts.ticketPriority.data.datasets[0].data = [low, medium, high, critical];
        this.charts.ticketPriority.update('none');
      }
    }

    handleRealtimeUpdate(update) {
      // Add animation for real-time updates
      Object.values(this.charts).forEach(chart => {
        if (chart) {
          chart.update('active');
        }
      });

      // Show notification
      this.showUpdateNotification(update.type);
    }

    showUpdateNotification(type) {
      // Create a subtle notification for real-time updates
      const notification = document.createElement('div');
      notification.className = 'fixed top-4 right-4 bg-green-500 text-white px-4 py-2 rounded-lg shadow-lg z-50 animate-pulse';
      notification.textContent = `${type.charAt(0).toUpperCase() + type.slice(1)} data updated`;
      document.body.appendChild(notification);

      setTimeout(() => {
        notification.remove();
      }, 3000);
    }

    refreshAllCharts() {
      const refreshBtn = document.getElementById('chartRefreshBtn');
      const icon = refreshBtn?.querySelector('i');
      
      if (icon) {
        icon.classList.add('fa-spin');
      }

      // Fetch fresh data and update all charts
      Promise.all([
        fetch('/api/dashboard/stats').then(r => r.json()),
        fetch('/api/dashboard/analytics/performance?period=30d').then(r => r.json())
      ])
        .then(([stats, performance]) => {
          this.updateCharts(stats);
          this.updateKPIs(stats);
          this.updateAdvancedKPIs(performance);
          
          // Update time-based charts with new data
          this.updateTimeBasedCharts();
        })
        .catch(error => {
          console.error('Error refreshing charts:', error);
        })
        .finally(() => {
          if (icon) {
            setTimeout(() => icon.classList.remove('fa-spin'), 1000);
          }
        });
    }

    loadKPIData() {
      // Load initial KPI data
      Promise.all([
        fetch('/api/dashboard/stats').then(r => r.json()),
        fetch('/api/dashboard/analytics/performance?period=30d').then(r => r.json())
      ])
        .then(([stats, performance]) => {
          this.updateKPIs(stats);
          this.updateAdvancedKPIs(performance);
        })
        .catch(error => {
          console.error('Error loading KPI data:', error);
        });
    }

    updateKPIs(stats) {
      // Calculate project health score
      const projectHealth = this.calculateProjectHealth(stats);
      this.updateKPIMetric('projectHealthScore', 'projectHealthBar', projectHealth, 100);

      // Calculate productivity score
      const productivity = this.calculateProductivity(stats);
      this.updateKPIMetric('productivityScore', 'productivityBar', productivity, 50);

      // Calculate satisfaction score (mock data for now)
      const satisfaction = this.calculateSatisfaction(stats);
      this.updateKPIMetric('satisfactionScore', 'satisfactionBar', satisfaction, 5);

      // Calculate budget efficiency
      const budgetEff = this.calculateBudgetEfficiency(stats);
      this.updateKPIMetric('budgetEfficiency', 'budgetBar', budgetEff, 100);
    }

    updateAdvancedKPIs(performance) {
      // Update KPIs with advanced analytics data
      if (performance.projectPerformance) {
        const healthScore = Math.round(
          (performance.projectPerformance.onTimeCompletionRate || 0) * 0.4 +
          (performance.milestoneCompletion.completedMilestones || 0) * 0.3 +
          (performance.ticketResolution.resolutionRate || 0) * 0.3
        );
        this.updateKPIMetric('projectHealthScore', 'projectHealthBar', healthScore, 100);
      }

      if (performance.ticketResolution) {
        const productivity = Math.round(
          (performance.ticketResolution.resolutionRate || 0) * 0.6 +
          (performance.ticketResolution.slaComplianceRate || 0) * 0.4
        );
        this.updateKPIMetric('productivityScore', 'productivityBar', productivity, 100);
      }
    }

    updateKPIMetric(scoreId, barId, value, maxValue) {
      const scoreEl = document.getElementById(scoreId);
      const barEl = document.getElementById(barId);
      
      if (scoreEl && barEl) {
        // Animate the score
        const currentValue = parseFloat(scoreEl.textContent) || 0;
        const targetValue = value;
        const duration = 1000;
        const startTime = Date.now();

        const animate = () => {
          const elapsed = Date.now() - startTime;
          const progress = Math.min(elapsed / duration, 1);
          const easeProgress = 1 - Math.pow(1 - progress, 3); // Ease out cubic
          
          const currentVal = currentValue + (targetValue - currentValue) * easeProgress;
          
          // Format based on metric type
          if (scoreId === 'satisfactionScore') {
            scoreEl.textContent = currentVal.toFixed(1);
          } else if (scoreId === 'budgetEfficiency') {
            scoreEl.textContent = `${Math.round(currentVal)}%`;
          } else {
            scoreEl.textContent = Math.round(currentVal);
          }

          // Update progress bar
          const percentage = (currentVal / maxValue) * 100;
          barEl.style.width = `${Math.min(percentage, 100)}%`;

          if (progress < 1) {
            requestAnimationFrame(animate);
          }
        };

        requestAnimationFrame(animate);
      }
    }

    calculateProjectHealth(stats) {
      if (!stats.projects || !stats.milestones) return 75;

      const projectScore = (stats.projects.completed / Math.max(stats.projects.total, 1)) * 40;
      const milestoneScore = (stats.milestones.completed / Math.max(stats.milestones.total, 1)) * 35;
      const ticketScore = stats.tickets.total > 0 ? 
        ((stats.tickets.total - stats.tickets.open) / stats.tickets.total) * 25 : 25;

      return Math.round(projectScore + milestoneScore + ticketScore);
    }

    calculateProductivity(stats) {
      if (!stats.tickets || !stats.milestones) return 25;

      const resolvedTickets = stats.tickets.total - stats.tickets.open - stats.tickets.inProgress;
      const completedMilestones = stats.milestones.completed;
      
      // Productivity = resolved tickets + completed milestones * 2
      return Math.round(resolvedTickets + (completedMilestones * 2));
    }

    calculateSatisfaction(stats) {
      // Mock satisfaction calculation based on project completion and ticket resolution
      if (!stats.projects || !stats.tickets) return 4.2;

      const completionRate = stats.projects.completed / Math.max(stats.projects.total, 1);
      const resolutionRate = stats.tickets.total > 0 ? 
        (stats.tickets.total - stats.tickets.open) / stats.tickets.total : 1;

      // Scale to 1-5 rating
      const satisfaction = (completionRate * 0.6 + resolutionRate * 0.4) * 5;
      return Math.round(satisfaction * 10) / 10;
    }

    calculateBudgetEfficiency(stats) {
      if (!stats.invoices) return 85;

      // Mock budget efficiency based on invoice payment rates
      const paidRate = stats.invoices.total > 0 ? 
        (stats.invoices.total - stats.invoices.pending) / stats.invoices.total : 1;

      return Math.round(paidRate * 100);
    }

    updateTimeBasedCharts() {
      // Update revenue trend chart
      if (this.charts.revenueTrend) {
        const labels = this.generateTimeLabels();
        const revenueData = this.generateRevenueData(labels.length);
        
        this.charts.revenueTrend.data.labels = labels;
        this.charts.revenueTrend.data.datasets[0].data = revenueData;
        this.charts.revenueTrend.update('none');
      }

      // Update completion rate chart
      if (this.charts.completionRate) {
        const labels = this.generateTimeLabels();
        const completionData = labels.map(() => Math.floor(Math.random() * 30) + 70);
        
        this.charts.completionRate.data.labels = labels;
        this.charts.completionRate.data.datasets[0].data = completionData;
        this.charts.completionRate.update('none');
      }
    }
  }

  // Initialize charts when DOM is ready
  document.addEventListener('DOMContentLoaded', () => {
    new DashboardCharts();
  });
</script>

<style>
  canvas {
    max-width: 100%;
    height: auto;
  }
</style>